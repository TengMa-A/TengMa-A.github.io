<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>探索garnet的epoch同步机制 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1. 设计epoch同步机制的目的garnet数据库是一个多线程的模型，这必然会导致当某些线程正在执行命令，比如底层的upsert操作时，另一个线程需要执行内存垃圾回收&#x2F;索引扩展&#x2F;环形队列维护&#x2F;页刷脏到磁盘等。如何能安全的同时进行这两步操作，并且不影响性能是多线程数据库面临的一个难点。因而，garnet数据库提出了一种新的机制：通过一个全局的epoch数据结构，保证任">
<meta property="og:type" content="article">
<meta property="og:title" content="探索garnet的epoch同步机制">
<meta property="og:url" content="http://tengma-a.github.io/2024/07/24/%E6%8E%A2%E7%B4%A2garnet%E7%9A%84epoch%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. 设计epoch同步机制的目的garnet数据库是一个多线程的模型，这必然会导致当某些线程正在执行命令，比如底层的upsert操作时，另一个线程需要执行内存垃圾回收&#x2F;索引扩展&#x2F;环形队列维护&#x2F;页刷脏到磁盘等。如何能安全的同时进行这两步操作，并且不影响性能是多线程数据库面临的一个难点。因而，garnet数据库提出了一种新的机制：通过一个全局的epoch数据结构，保证任">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://tengma-a.github.io/images/epoch.png">
<meta property="article:published_time" content="2024-07-24T15:51:46.000Z">
<meta property="article:modified_time" content="2024-08-04T09:19:00.168Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://tengma-a.github.io/images/epoch.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://TengMa-A.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-探索garnet的epoch保护机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/24/%E6%8E%A2%E7%B4%A2garnet%E7%9A%84epoch%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2024-07-24T15:51:46.000Z" itemprop="datePublished">2024-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      探索garnet的epoch同步机制
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-设计epoch同步机制的目的"><a href="#1-设计epoch同步机制的目的" class="headerlink" title="1. 设计epoch同步机制的目的"></a>1. 设计epoch同步机制的目的</h2><p>garnet数据库是一个多线程的模型，这必然会导致当某些线程正在执行命令，比如底层的upsert操作时，另一个线程需要执行内存垃圾回收&#x2F;索引扩展&#x2F;环形队列维护&#x2F;页刷脏到磁盘等。如何能安全的同时进行这两步操作，并且不影响性能是多线程数据库面临的一个难点。因而，garnet数据库提出了一种新的机制：通过一个全局的epoch数据结构，保证任何一个线程对数据库整体产生的影响，能够被安全的传播给所有的线程。</p>
<span id="more"></span>

<h2 id="2-epoch的数据结构设计"><a href="#2-epoch的数据结构设计" class="headerlink" title="2. epoch的数据结构设计"></a>2. epoch的数据结构设计</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">unsafe</span> <span class="keyword">class</span> <span class="title">LightEpoch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Store thread-static metadata separately from the LightEpoch class because LightEpoch has a static ctor,</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> and this inhibits optimization of the .NET helper function that determines the base address of the static variables.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> This is expensive as it goes through multiple lookups, so lift these into a class that does not have a static ctor.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">TODO:</span> This should be fixed in .NET 8; verify this and remove the Metadata class code when we no longer support pre-NET.8.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Metadata</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Managed thread id of this thread</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">ThreadStatic</span>]</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">int</span> threadId;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Start offset to reserve entry in the epoch table</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">ThreadStatic</span>]</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">ushort</span> startOffset1;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Alternate start offset to reserve entry in the epoch table (to reduce probing if <span class="doctag">&lt;see cref=&quot;startOffset1&quot;/&gt;</span> slot is already filled)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">ThreadStatic</span>]</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">ushort</span> startOffset2;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> A thread&#x27;s entry in the epoch table.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">ThreadStatic</span>]</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">int</span> threadEntryIndex;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Number of instances using this entry</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">ThreadStatic</span>]</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="built_in">int</span> threadEntryIndexCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Size of cache line in bytes</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> kCacheLineBytes = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Default invalid index entry.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> kInvalidIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Default number of entries in the entries table</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">ushort</span> kTableSize = Math.Max((<span class="built_in">ushort</span>)<span class="number">128</span>, (<span class="built_in">ushort</span>)(Environment.ProcessorCount * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Default drainlist size</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> kDrainListSize = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Thread protection status entries.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">readonly</span> Entry[] tableRaw;</span><br><span class="line">    <span class="keyword">readonly</span> Entry* tableAligned;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> Entry[] threadIndex;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> Entry* threadIndexAligned;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> List of action, epoch pairs containing actions to be performed when an epoch becomes safe to reclaim.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Marked volatile to ensure latest value is seen by the last suspended thread.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="built_in">int</span> drainCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">readonly</span> EpochActionPair[] drainList = <span class="keyword">new</span> EpochActionPair[kDrainListSize];</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Global current epoch value</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">long</span> CurrentEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Cached value of latest epoch that is safe to reclaim</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">long</span> SafeToReclaimEpoch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块中lightEpoch比较关键的field包括了Metadata（每个线程独有的参数信息），tableRaw（存储了线程id,当前线程的版本即epoch）, threadIndex(存储了线程id)。其中的tableAligned和threadIndexAligned是按照字节数对齐后的地址，实际用来访问的基地址，tableraw等数组只是提供了一个连续的内存空间供我们使用。</p>
<p>重点介绍该数据结构的几个实现方法：</p>
<p>1.Resume</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Resume</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Acquire();</span><br><span class="line">    ProtectAndDrain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acquire</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Metadata.threadEntryIndex == kInvalidIndex)</span><br><span class="line">        Metadata.threadEntryIndex = ReserveEntryForThread();</span><br><span class="line"></span><br><span class="line">    Debug.Assert((*(tableAligned + Metadata.threadEntryIndex)).localCurrentEpoch == <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;Trying to acquire protected epoch. Make sure you do not re-enter Tsavorite from callbacks or IDevice implementations. If using tasks, use TaskCreationOptions.RunContinuationsAsynchronously.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This corresponds to AnyInstanceProtected(). We do not mark &quot;ThisInstanceProtected&quot; until ProtectAndDrain().</span></span><br><span class="line">    Metadata.threadEntryIndexCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Enter the thread into the protected code region</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>Current epoch<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProtectAndDrain</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> entry = Metadata.threadEntryIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protect CurrentEpoch by making an entry for it in the non-static epoch table so ComputeNewSafeToReclaimEpoch() will see it.</span></span><br><span class="line">    (*(tableAligned + entry)).threadId = Metadata.threadEntryIndex;</span><br><span class="line">    (*(tableAligned + entry)).localCurrentEpoch = CurrentEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drainCount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Drain((*(tableAligned + entry)).localCurrentEpoch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resume函数分为两步:</p>
<p>Acquire()的具体作用是使当前调用它的线程被分配一个线程id,同时将其记录到threadIndexAligned和tableAligned中，代表CurrentEpoch被该线程标记。那么这样做的目的是什么呢？实现安全的延迟的全局同步操作而不会导致并发问题。假设这个table被各种不同的线程id填满。</p>
<p>如下图所示<img src="/images/epoch.png">，</p>
<p>那么我们会有一个最小的epoch,它没有被任何的线程标记，也就是说任何与这个epoch相关联的全局操作，都不会导致这些正在运行的线程产生并发问题。因为他们不在一个epoch中，你所带来的修改不会影响到更新的epoch版本。</p>
<p>ProtectAndDrain()的作用是当所有线程所持有的epoch都大于我们需要执行的全局操作绑定的epoch时，执行这些动作。这一限制条件保证了，这个全局修改所带来的影响的不会波及到当前正在执行的所有线程。</p>
<p>2.Suspend</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Thread suspends its epoch entry</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Suspend</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Release();</span><br><span class="line">    <span class="keyword">if</span> (drainCount &gt; <span class="number">0</span>) SuspendDrain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Release代表我们需要将tableAligned和threadIndexAligned这两个全局指针对应index的数据清空，代表这个线程不再标记当前的epoch.SuspendDrain()的作用和ProtectAndDrain()函数的作用类似，但它是通过再次重复调用resume和release两个函数，利用其边缘作用，即会执行Drain命令来实现的。</p>
<p>3.BumpCurrentEpoch</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Increment global current epoch</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="built_in">long</span> <span class="title">BumpCurrentEpoch</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Assert(ThisInstanceProtected(), <span class="string">&quot;BumpCurrentEpoch must be called on a protected thread&quot;</span>);</span><br><span class="line">    <span class="built_in">long</span> nextEpoch = Interlocked.Increment(<span class="keyword">ref</span> CurrentEpoch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drainCount &gt; <span class="number">0</span>)</span><br><span class="line">        Drain(nextEpoch);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComputeNewSafeToReclaimEpoch(nextEpoch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextEpoch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Increment current epoch and associate trigger action</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> with the prior epoch</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;onDrain&quot;&gt;</span>Trigger action<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BumpCurrentEpoch</span>(<span class="params">Action onDrain</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">long</span> PriorEpoch = BumpCurrentEpoch() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (drainList[i].epoch == <span class="built_in">long</span>.MaxValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This was an empty slot. If it still is, assign this action/epoch to the slot.</span></span><br><span class="line">            <span class="keyword">if</span> (Interlocked.CompareExchange(<span class="keyword">ref</span> drainList[i].epoch, <span class="built_in">long</span>.MaxValue - <span class="number">1</span>, <span class="built_in">long</span>.MaxValue) == <span class="built_in">long</span>.MaxValue)</span><br><span class="line">            &#123;</span><br><span class="line">                drainList[i].action = onDrain;</span><br><span class="line">                drainList[i].epoch = PriorEpoch;</span><br><span class="line">                Interlocked.Increment(<span class="keyword">ref</span> drainCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> triggerEpoch = drainList[i].epoch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (triggerEpoch &lt;= SafeToReclaimEpoch)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// This was a slot with an epoch that was safe to reclaim. If it still is, execute its trigger, then assign this action/epoch to the slot.</span></span><br><span class="line">                <span class="keyword">if</span> (Interlocked.CompareExchange(<span class="keyword">ref</span> drainList[i].epoch, <span class="built_in">long</span>.MaxValue - <span class="number">1</span>, triggerEpoch) == triggerEpoch)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> triggerAction = drainList[i].action;</span><br><span class="line">                    drainList[i].action = onDrain;</span><br><span class="line">                    drainList[i].epoch = PriorEpoch;</span><br><span class="line">                    triggerAction();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++i == kDrainListSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// We are at the end of the drain list and found no empty or reclaimable slot. ProtectAndDrain, which should clear one or more slots.</span></span><br><span class="line">            ProtectAndDrain();</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            Thread.Yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now ProtectAndDrain, which may execute the action we just added.</span></span><br><span class="line">    ProtectAndDrain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这BumpCurrentEpoch函数会计算出一个新的safe epoch(即所有的执行线程的epoch都大于这个epoch)，而第二个带有Action为入参的函数，是将当前这个epoch与一个可以执行的函数进行绑定，当我们进入到drain逻辑是，会遍历所有的epoch, 看它是否绑定了action, 如果有且小于safe epoch, 我们就需要执行它。</p>
<h2 id="3-epoch机制的使用案例"><a href="#3-epoch机制的使用案例" class="headerlink" title="3. epoch机制的使用案例"></a>3. epoch机制的使用案例</h2><p>我们以数据库底层的RWM操作为例进行说明（在执行hset命令时会进入到该逻辑）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;inheritdoc/&gt;</span></span></span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> Status <span class="title">RMW</span>(<span class="params"><span class="keyword">ref</span> Key key, <span class="built_in">long</span> keyHash, <span class="keyword">ref</span> Input input, <span class="keyword">ref</span> Output output, <span class="keyword">out</span> RecordMetadata recordMetadata, Context userContext = <span class="literal">default</span>, <span class="built_in">long</span> serialNo = <span class="number">0</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    UnsafeResumeThread();</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> store.ContextRMW(<span class="keyword">ref</span> key, keyHash, <span class="keyword">ref</span> input, <span class="keyword">ref</span> output, <span class="keyword">out</span> recordMetadata, userContext, TsavoriteSession, serialNo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        UnsafeSuspendThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnsafeResumeThread函数内部为Resume和InternalRefresh两个函数共同组成，其中InternalRefresh有如下作用:1.执行safe epoch以下的所有全局操作 2. 确保所有线程没有在执行多key命令，且全局状态机处于IN_PROGRESS状态，同时当前的版本为v+1(假设之前的版本为v). 当ContextRMW执行返回后，我们还要通过suspend函数将该线程从全局表tableAligned中去除（重置）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;summary&gt;</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Resume session on current thread. IMPORTANT: Call SuspendThread before any async op.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">MethodImpl(MethodImplOptions.AggressiveInlining)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">UnsafeResumeThread</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We do not track any &quot;acquired&quot; state here; if someone mixes calls between safe and unsafe contexts, they will </span></span><br><span class="line">    <span class="comment">// get the &quot;trying to acquire already-acquired epoch&quot; error.</span></span><br><span class="line">    store.epoch.Resume();</span><br><span class="line">    store.InternalRefresh&lt;Input, Output, Context, InternalTsavoriteSession&gt;(TsavoriteSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如此时，有另一个线程需要执行将修改的页面刷入磁盘，那么该如何并发安全的执行呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Used by applications to make the current state of the database immutable quickly</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;tailAddress&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;notifyDone&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ShiftReadOnlyToTail</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">long</span> tailAddress, <span class="keyword">out</span> SemaphoreSlim notifyDone</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    notifyDone = <span class="literal">null</span>;</span><br><span class="line">    tailAddress = GetTailAddress();</span><br><span class="line">    <span class="built_in">long</span> localTailAddress = tailAddress;</span><br><span class="line">    <span class="keyword">if</span> (Utility.MonotonicUpdate(<span class="keyword">ref</span> ReadOnlyAddress, tailAddress, <span class="keyword">out</span> _))</span><br><span class="line">    &#123;</span><br><span class="line">        notifyFlushedUntilAddressSemaphore = <span class="keyword">new</span> SemaphoreSlim(<span class="number">0</span>);</span><br><span class="line">        notifyDone = notifyFlushedUntilAddressSemaphore;</span><br><span class="line">        notifyFlushedUntilAddress = localTailAddress;</span><br><span class="line">        epoch.BumpCurrentEpoch(() =&gt; OnPagesMarkedReadOnly(localTailAddress));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，该线程利用了epoch的BumpCurrentEpoch函数，只有当所有正在执行命令的thread所处的epoch高于当前调用此函数ShiftReadOnlyToTail的thread所在的epoch时，OnPagesMarkedReadOnly才会被调用，并会将tailAddress-ReadOnlyAddress这一段的数据全部刷新到磁盘中。这么做的目的，就是防止出现当前线程正在将这些数据刷新到磁盘时，另外的线程又正在进行修改，导致内存中记录的数据和磁盘中不一致造成数据丢失的问题。</p>
<h2 id="4-epoch机制的思考"><a href="#4-epoch机制的思考" class="headerlink" title="4. epoch机制的思考"></a>4. epoch机制的思考</h2><p>这种机制保证了在多线程环境下的延迟同步功能，但也只适用于这种append only的存储引擎模型。对于需要在磁盘文件上原地更新的存储引擎，由于其数据没有版本的概念（通过锁机制保证，每一个线程看到的数据都是最新的）无法很好的适配。例如当要将脏页刷入磁盘时，如果在这个过程中还有命令执行，碰巧修改了这个页的数据，那么会造成数据不一致的问题。而append only方式的存储，保证了此刻不会有任何的线程会更新内存中的脏页（大部分数据是追加更新，只有mutable区域的数据可以原地更新）。</p>
<p>假如原地更新的存储模型也带有版本号的信息（类似于关系型数据库的MVCC概念），那么epoch这种延迟更新的机制是可以尝试的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://tengma-a.github.io/2024/07/24/%E6%8E%A2%E7%B4%A2garnet%E7%9A%84epoch%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" data-id="clzfb9ewx00000wkv3gq91e8y" data-title="探索garnet的epoch同步机制" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/06/24/%E6%8E%A2%E7%B4%A2Garnet%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84Upsert%E6%93%8D%E4%BD%9C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">探索Garnet数据库中的Upsert操作</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/24/%E6%8E%A2%E7%B4%A2garnet%E7%9A%84epoch%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">探索garnet的epoch同步机制</a>
          </li>
        
          <li>
            <a href="/2024/06/24/%E6%8E%A2%E7%B4%A2Garnet%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84Upsert%E6%93%8D%E4%BD%9C/">探索Garnet数据库中的Upsert操作</a>
          </li>
        
          <li>
            <a href="/2024/06/15/%E6%8E%A2%E8%AE%A8Garnet%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E8%A3%82%E4%B8%8E%E7%AE%A1/">探讨Garnet数据库：哈希索引的分裂与管理</a>
          </li>
        
          <li>
            <a href="/2024/06/15/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>